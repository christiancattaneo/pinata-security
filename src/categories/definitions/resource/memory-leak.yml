id: memory-leak
version: 1
name: Memory Leak
description: |
  Detects memory leaks where allocated memory is not properly released. Includes 
  growing caches without eviction, event listener accumulation, circular references, 
  and closure-captured variables. Memory leaks cause OOM crashes and degraded 
  performance over time.
domain: resource
level: integration
priority: P0
severity: critical
applicableLanguages:
  - python
  - typescript
  - javascript

cves:
  - CVE-2021-22959
  - CVE-2020-8174

references:
  - https://cwe.mitre.org/data/definitions/401.html
  - https://cwe.mitre.org/data/definitions/772.html
  - https://developer.chrome.com/docs/devtools/memory-problems/

detectionPatterns:
  - id: python-cache-no-limit
    type: regex
    language: python
    pattern: "\\{\\}|dict\\(\\)(?!.*maxsize|.*lru_cache|.*TTLCache)"
    confidence: low
    description: Detects unbounded dict cache (verify eviction)

  - id: python-list-append-loop
    type: regex
    language: python
    pattern: "while.*\\.append\\(|for.*\\.append\\("
    confidence: low
    description: Detects list growing in loop (verify bounds)

  - id: python-global-accumulator
    type: regex
    language: python
    pattern: "global\\s+\\w+.*\\.append|global\\s+\\w+.*\\["
    confidence: medium
    description: Detects global collection accumulation

  - id: python-lru-no-maxsize
    type: regex
    language: python
    pattern: "@lru_cache\\(\\)|@lru_cache$"
    confidence: high
    description: Detects lru_cache without maxsize (unbounded)

  - id: python-circular-ref
    type: regex
    language: python
    pattern: "self\\.\\w+\\s*=\\s*self|self\\.parent\\s*=|self\\.\\w+\\.\\w+\\s*=\\s*self"
    confidence: medium
    description: Detects potential circular references

  - id: ts-cache-no-limit
    type: regex
    language: typescript
    pattern: "new\\s+Map\\(\\)|new\\s+Set\\(\\)|\\{\\}\\s*as\\s+Record"
    confidence: low
    description: Detects unbounded cache structures

  - id: ts-event-listener-no-remove
    type: regex
    language: typescript
    pattern: "\\.addEventListener\\((?!.*removeEventListener)"
    confidence: medium
    description: Detects event listeners without removal

  - id: ts-closure-capture
    type: regex
    language: typescript
    pattern: "setInterval\\(|setTimeout\\((?!.*clearInterval|.*clearTimeout)"
    confidence: medium
    description: Detects timers that may leak closures

  - id: ts-array-push-unbounded
    type: regex
    language: typescript
    pattern: "\\.push\\(.*\\)(?!.*slice|.*splice|.*shift|.*length\\s*=)"
    confidence: low
    description: Detects array growth without bounds

testTemplates:
  - id: pytest-memory-leak
    language: python
    framework: pytest
    template: |
      import pytest
      import gc
      import sys
      import weakref
      from memory_profiler import memory_usage
      
      class Test{{className}}MemoryLeak:
          """Memory leak tests for {{functionName}}"""
          
          def test_no_memory_growth(self, {{fixtures}}):
              """Test memory does not grow unboundedly"""
              gc.collect()
              initial_objects = len(gc.get_objects())
              
              for _ in range(1000):
                  {{functionCall}}()
              
              gc.collect()
              final_objects = len(gc.get_objects())
              
              growth = final_objects - initial_objects
              assert growth < 100, f"Object count grew by {growth}"
          
          def test_objects_released(self, {{fixtures}}):
              """Test objects are properly garbage collected"""
              refs = []
              
              for _ in range(100):
                  obj = {{createObjectCall}}()
                  refs.append(weakref.ref(obj))
              
              del obj
              gc.collect()
              
              alive = sum(1 for ref in refs if ref() is not None)
              assert alive < 10, f"{alive} objects not collected"
          
          def test_cache_has_limit(self, {{fixtures}}):
              """Test cache does not grow unboundedly"""
              for i in range(10000):
                  {{cacheCall}}(f"key_{i}", f"value_{i}")
              
              cache_size = {{getCacheSizeCall}}()
              assert cache_size < 1000, f"Cache grew to {cache_size} items"
          
          def test_memory_stable_under_load(self, {{fixtures}}):
              """Test memory usage is stable under sustained load"""
              def run_operations():
                  for _ in range(1000):
                      {{functionCall}}()
              
              mem_before = memory_usage()[0]
              
              for _ in range(10):
                  run_operations()
                  gc.collect()
              
              mem_after = memory_usage()[0]
              growth_mb = mem_after - mem_before
              
              assert growth_mb < 50, f"Memory grew by {growth_mb}MB"
          
          def test_circular_reference_cleanup(self, {{fixtures}}):
              """Test circular references are broken"""
              gc.collect()
              gc.set_debug(gc.DEBUG_SAVEALL)
              
              {{createCircularCall}}()
              
              gc.collect()
              
              # Check for uncollectable objects
              assert len(gc.garbage) == 0, f"Uncollectable objects: {len(gc.garbage)}"
              gc.set_debug(0)
    variables:
      - name: className
        type: string
        description: Class name
        required: true
      - name: functionName
        type: string
        description: Function name
        required: true
      - name: functionCall
        type: string
        description: Main function call
        required: true
      - name: createObjectCall
        type: string
        description: Object creation call
        required: true
      - name: cacheCall
        type: string
        description: Cache set call
        required: true
      - name: getCacheSizeCall
        type: string
        description: Get cache size call
        required: true
      - name: createCircularCall
        type: string
        description: Circular reference creation
        required: true
      - name: fixtures
        type: string
        description: pytest fixtures
        required: false
        defaultValue: ""

  - id: jest-memory-leak
    language: typescript
    framework: jest
    template: |
      import { {{functionName}} } from '{{modulePath}}';
      
      describe('{{className}} Memory Leak Tests', () => {
        describe('object cleanup', () => {
          it('does not retain references', async () => {
            const registry = new FinalizationRegistry(() => {});
            const refs: WeakRef<object>[] = [];
            
            for (let i = 0; i < 100; i++) {
              const obj = await {{createObjectCall}}();
              refs.push(new WeakRef(obj));
            }
            
            // Force GC if available
            if (global.gc) global.gc();
            
            await new Promise(r => setTimeout(r, 100));
            
            const alive = refs.filter(r => r.deref() !== undefined).length;
            expect(alive).toBeLessThan(10);
          });
        });
        
        describe('event listeners', () => {
          it('removes listeners on cleanup', async () => {
            const target = new EventTarget();
            let listenerCount = 0;
            
            const originalAdd = target.addEventListener.bind(target);
            const originalRemove = target.removeEventListener.bind(target);
            
            target.addEventListener = (...args) => {
              listenerCount++;
              return originalAdd(...args);
            };
            target.removeEventListener = (...args) => {
              listenerCount--;
              return originalRemove(...args);
            };
            
            const cleanup = {{attachListenersCall}}(target);
            expect(listenerCount).toBeGreaterThan(0);
            
            cleanup();
            expect(listenerCount).toBe(0);
          });
        });
        
        describe('cache bounds', () => {
          it('limits cache size', async () => {
            for (let i = 0; i < 10000; i++) {
              await {{cacheCall}}(`key_${i}`, `value_${i}`);
            }
            
            const size = await {{getCacheSizeCall}}();
            expect(size).toBeLessThan(1000);
          });
          
          it('evicts old entries', async () => {
            await {{cacheCall}}('old_key', 'old_value');
            
            for (let i = 0; i < 1000; i++) {
              await {{cacheCall}}(`key_${i}`, `value_${i}`);
            }
            
            const oldValue = await {{getCacheCall}}('old_key');
            expect(oldValue).toBeUndefined();
          });
        });
        
        describe('timers', () => {
          it('clears intervals on cleanup', async () => {
            const originalSetInterval = global.setInterval;
            const originalClearInterval = global.clearInterval;
            
            const activeIntervals = new Set<NodeJS.Timeout>();
            
            global.setInterval = ((...args) => {
              const id = originalSetInterval(...args);
              activeIntervals.add(id);
              return id;
            }) as typeof setInterval;
            
            global.clearInterval = ((id: NodeJS.Timeout) => {
              activeIntervals.delete(id);
              return originalClearInterval(id);
            }) as typeof clearInterval;
            
            const cleanup = {{startIntervalsCall}}();
            expect(activeIntervals.size).toBeGreaterThan(0);
            
            cleanup();
            expect(activeIntervals.size).toBe(0);
            
            global.setInterval = originalSetInterval;
            global.clearInterval = originalClearInterval;
          });
        });
      });
    variables:
      - name: className
        type: string
        description: Class name
        required: true
      - name: functionName
        type: string
        description: Function name
        required: true
      - name: createObjectCall
        type: string
        description: Object creation call
        required: true
      - name: attachListenersCall
        type: string
        description: Attach listeners call
        required: true
      - name: cacheCall
        type: string
        description: Cache set call
        required: true
      - name: getCacheSizeCall
        type: string
        description: Get cache size
        required: true
      - name: getCacheCall
        type: string
        description: Get cache value
        required: true
      - name: startIntervalsCall
        type: string
        description: Start intervals call
        required: true
      - name: modulePath
        type: string
        description: Module path
        required: true

examples:
  - name: unbounded-cache
    concept: |
      Unbounded cache growth. Caching without a size limit causes memory to grow 
      indefinitely. Use LRU eviction or TTL expiration to bound cache size.
    vulnerableCode: |
      # VULNERABLE: Cache grows forever
      cache = {}
      
      def get_user(user_id):
          if user_id not in cache:
              cache[user_id] = fetch_user(user_id)
          return cache[user_id]
    testCode: |
      import pytest
      from functools import lru_cache
      
      def test_cache_bounded():
          for i in range(10000):
              get_user(f"user_{i}")
          
          assert len(cache) < 1000
      
      # Fixed version
      @lru_cache(maxsize=100)
      def get_user_safe(user_id):
          return fetch_user(user_id)
    language: python
    severity: high

  - name: event-listener-leak
    concept: |
      Event listener accumulation. Adding event listeners without removing them 
      causes memory leaks. Each listener holds references to its closure scope.
      Always remove listeners when components unmount.
    vulnerableCode: |
      class Component {
        constructor() {
          // VULNERABLE: Never removed
          window.addEventListener('resize', this.handleResize);
        }
        
        handleResize = () => {
          this.update();
        };
      }
    testCode: |
      describe('Component', () => {
        it('removes listeners on destroy', () => {
          const addSpy = jest.spyOn(window, 'addEventListener');
          const removeSpy = jest.spyOn(window, 'removeEventListener');
          
          const component = new Component();
          component.destroy();
          
          expect(removeSpy).toHaveBeenCalledWith('resize', expect.any(Function));
        });
      });
    language: typescript
    severity: high

  - name: closure-in-loop
    concept: |
      Closures capturing loop variables. Creating closures in loops that capture 
      large objects prevents garbage collection. The closure keeps the entire 
      scope alive.
    vulnerableCode: |
      def process_files(files):
          handlers = []
          
          for f in files:
              # VULNERABLE: Closure captures entire file content
              content = f.read()
              handlers.append(lambda: process(content))
          
          return handlers
    testCode: |
      import pytest
      import gc
      import weakref
      
      def test_no_file_content_retained():
          files = [create_large_file() for _ in range(100)]
          refs = [weakref.ref(f) for f in files]
          
          handlers = process_files(files)
          del files
          gc.collect()
          
          # Files should be collected
          alive = sum(1 for r in refs if r() is not None)
          assert alive == 0
    language: python
    severity: medium
    cve: CVE-2021-22959

createdAt: 2024-01-01
updatedAt: 2024-01-01
