id: hardcoded-secrets
version: 1
name: Hardcoded Secrets
description: |
  Detects hardcoded secrets, API keys, passwords, and credentials in source code.
  Secrets exposed in code are scraped within minutes of being pushed to public 
  repositories. Attackers use automated scanners (TruffleHog, gitleaks) to harvest
  credentials from GitHub/GitLab. Use environment variables, secret managers 
  (AWS Secrets Manager, HashiCorp Vault), or OS keychains instead.
  
  Detection confidence: HIGH (>90% for well-known patterns)
  This category uses regex patterns with entropy analysis for reliable detection.
domain: security
level: unit
priority: P0
severity: critical
applicableLanguages:
  - python
  - typescript
  - javascript

cves:
  - CVE-2019-19576
  - CVE-2021-23337
  - CVE-2022-0235

references:
  - https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password
  - https://cwe.mitre.org/data/definitions/798.html
  - https://cwe.mitre.org/data/definitions/259.html
  - https://github.com/trufflesecurity/trufflehog

detectionPatterns:
  # AWS Credentials
  - id: aws-access-key-id
    type: regex
    language: python
    pattern: "(AKIA|ABIA|ACCA|ASIA)[0-9A-Z]{16}"
    confidence: high
    description: Detects AWS Access Key ID (starts with AKIA/ABIA/ACCA/ASIA)

  - id: aws-secret-key
    type: regex
    language: python
    pattern: "aws.{0,20}secret.{0,20}['\"][0-9a-zA-Z/+=]{40}['\"]"
    confidence: high
    description: Detects AWS Secret Access Key (40 character base64)

  # API Keys - Generic patterns
  - id: generic-api-key
    type: regex
    language: python
    pattern: "(api[_-]?key|apikey)\\s*[=:]\\s*[\"'][a-zA-Z0-9_\\-]{20,}[\"']"
    confidence: high
    description: Detects generic API key assignments

  - id: generic-secret-key
    type: regex
    language: python
    pattern: "(secret[_-]?key|secretkey)\\s*[=:]\\s*[\"'][a-zA-Z0-9_\\-]{20,}[\"']"
    confidence: high
    description: Detects generic secret key assignments

  - id: bearer-token
    type: regex
    language: python
    pattern: "(bearer|token)\\s*[=:]\\s*[\"'][a-zA-Z0-9_\\-.]{20,}[\"']"
    confidence: medium
    description: Detects hardcoded bearer tokens

  # Private Keys
  - id: private-key-rsa
    type: regex
    language: python
    pattern: "-----BEGIN (RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----"
    confidence: high
    description: Detects embedded private keys (RSA, EC, DSA, OpenSSH)

  - id: private-key-pgp
    type: regex
    language: python
    pattern: "-----BEGIN PGP PRIVATE KEY BLOCK-----"
    confidence: high
    description: Detects embedded PGP private keys

  # JWT Tokens
  - id: jwt-token
    type: regex
    language: python
    pattern: "eyJ[a-zA-Z0-9_-]*\\.eyJ[a-zA-Z0-9_-]*\\.[a-zA-Z0-9_-]*"
    confidence: high
    description: Detects hardcoded JWT tokens (eyJ... format)

  # Database Credentials
  - id: database-password
    type: regex
    language: python
    pattern: "(db|database|mysql|postgres|mongo)[_-]?(password|pass|pwd)\\s*[=:]\\s*[\"'][^\"']{8,}[\"']"
    confidence: high
    description: Detects hardcoded database passwords

  - id: connection-string-password
    type: regex
    language: python
    pattern: "(mongodb|postgres|mysql|redis)://[^:]+:[^@]{8,}@"
    confidence: high
    description: Detects passwords in database connection strings

  # Common Service Tokens
  - id: github-token
    type: regex
    language: python
    pattern: "(gh[pousr]_[a-zA-Z0-9]{36}|github[_-]?token\\s*[=:]\\s*[\"'][a-zA-Z0-9_]{35,}[\"'])"
    confidence: high
    description: Detects GitHub personal access tokens

  - id: slack-token
    type: regex
    language: python
    pattern: "xox[baprs]-[0-9]{10,13}-[0-9]{10,13}[a-zA-Z0-9-]*"
    confidence: high
    description: Detects Slack API tokens

  - id: stripe-key
    type: regex
    language: python
    pattern: "(sk|pk)_(live|test)_[0-9a-zA-Z]{24,}"
    confidence: high
    description: Detects Stripe API keys (live or test)

  - id: twilio-key
    type: regex
    language: python
    pattern: "SK[0-9a-fA-F]{32}"
    confidence: high
    description: Detects Twilio API keys

  - id: sendgrid-key
    type: regex
    language: python
    pattern: "SG\\.[a-zA-Z0-9_-]{22}\\.[a-zA-Z0-9_-]{43}"
    confidence: high
    description: Detects SendGrid API keys

  # Google/Firebase
  - id: google-api-key
    type: regex
    language: python
    pattern: "AIza[0-9A-Za-z_-]{35}"
    confidence: high
    description: Detects Google API keys

  - id: firebase-key
    type: regex
    language: python
    pattern: "AAAA[A-Za-z0-9_-]{7}:[A-Za-z0-9_-]{140}"
    confidence: high
    description: Detects Firebase Cloud Messaging keys

  # Generic password patterns
  - id: password-variable
    type: regex
    language: python
    pattern: "(password|passwd|pwd)\\s*[=:]\\s*[\"'][^\"']{8,}[\"']"
    confidence: medium
    description: Detects hardcoded password assignments
    negativePattern: "password.*=.*os\\.environ|password.*=.*env\\.|getenv|process\\.env"

  # TypeScript/JavaScript specific
  - id: ts-api-key
    type: regex
    language: typescript
    pattern: "(api[_-]?key|apiKey)\\s*[=:]\\s*[\"'`][a-zA-Z0-9_\\-]{20,}[\"'`]"
    confidence: high
    description: Detects hardcoded API keys in TypeScript

  - id: ts-secret-env-bypass
    type: regex
    language: typescript
    pattern: "(secret|token|key|password)\\s*[=:]\\s*[\"'`][^\"'`]{8,}[\"'`](?!.*process\\.env)"
    confidence: medium
    description: Detects secrets not loaded from environment

testTemplates:
  - id: pytest-secrets
    language: python
    framework: pytest
    template: |
      import pytest
      import re
      import os
      from pathlib import Path
      
      
      class Test{{className}}Secrets:
          """Secret detection tests for {{moduleName}}"""
          
          SECRET_PATTERNS = [
              (r'AKIA[0-9A-Z]{16}', 'AWS Access Key'),
              (r'-----BEGIN (RSA |EC )?PRIVATE KEY-----', 'Private Key'),
              (r'eyJ[a-zA-Z0-9_-]*\.eyJ[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*', 'JWT Token'),
              (r'(gh[pousr]_[a-zA-Z0-9]{36})', 'GitHub Token'),
              (r'(sk|pk)_(live|test)_[0-9a-zA-Z]{24,}', 'Stripe Key'),
              (r'xox[baprs]-[0-9]{10,13}-[0-9]{10,13}[a-zA-Z0-9-]*', 'Slack Token'),
          ]
          
          def test_no_hardcoded_secrets_in_source(self):
              """Verify no secrets are hardcoded in source files"""
              source_file = Path("{{sourceFile}}")
              content = source_file.read_text()
              
              for pattern, secret_type in self.SECRET_PATTERNS:
                  matches = re.findall(pattern, content)
                  assert not matches, f"Found hardcoded {secret_type} in {source_file}"
          
          def test_secrets_loaded_from_environment(self):
              """Verify secrets are loaded from environment or secret manager"""
              from {{modulePath}} import {{configClass}}
              
              # These should be loaded from env, not hardcoded
              config = {{configClass}}()
              
              # Verify config doesn't contain actual secrets
              config_str = str(vars(config))
              for pattern, secret_type in self.SECRET_PATTERNS:
                  matches = re.findall(pattern, config_str)
                  assert not matches, f"Config contains hardcoded {secret_type}"
          
          def test_env_vars_used_for_secrets(self):
              """Verify environment variables are used for sensitive config"""
              required_env_vars = [
                  "{{envVarPrefix}}_API_KEY",
                  "{{envVarPrefix}}_SECRET_KEY",
                  "DATABASE_URL",
              ]
              
              # Check that code references env vars
              import inspect
              from {{modulePath}} import {{functionName}}
              
              source = inspect.getsource({{functionName}})
              
              # Should use os.environ or os.getenv
              assert "os.environ" in source or "os.getenv" in source or \
                     "env." in source.lower(), \
                  "Secrets should be loaded from environment variables"
          
          def test_gitignore_excludes_env_files(self):
              """Verify .env files are gitignored"""
              gitignore = Path(".gitignore")
              if gitignore.exists():
                  content = gitignore.read_text()
                  assert ".env" in content, ".env should be in .gitignore"
                  assert "*.pem" in content or ".pem" in content, \
                      "Private key files should be gitignored"
    variables:
      - name: className
        type: string
        description: Name of the test class
        required: true
      - name: moduleName
        type: string
        description: Name of the module being tested
        required: true
      - name: sourceFile
        type: string
        description: Path to source file to scan
        required: true
      - name: modulePath
        type: string
        description: Import path for the module
        required: true
      - name: configClass
        type: string
        description: Configuration class name
        required: false
        defaultValue: Config
      - name: envVarPrefix
        type: string
        description: Prefix for environment variables
        required: false
        defaultValue: APP
      - name: functionName
        type: string
        description: Function to inspect for env usage
        required: true

  - id: jest-secrets
    language: typescript
    framework: jest
    template: |
      import * as fs from 'fs';
      import * as path from 'path';
      
      describe('{{className}} Secret Detection', () => {
        const SECRET_PATTERNS = [
          { pattern: /AKIA[0-9A-Z]{16}/, name: 'AWS Access Key' },
          { pattern: /-----BEGIN (RSA |EC )?PRIVATE KEY-----/, name: 'Private Key' },
          { pattern: /eyJ[a-zA-Z0-9_-]*\.eyJ[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*/, name: 'JWT Token' },
          { pattern: /gh[pousr]_[a-zA-Z0-9]{36}/, name: 'GitHub Token' },
          { pattern: /(sk|pk)_(live|test)_[0-9a-zA-Z]{24,}/, name: 'Stripe Key' },
          { pattern: /xox[baprs]-[0-9]{10,13}-[0-9]{10,13}[a-zA-Z0-9-]*/, name: 'Slack Token' },
        ];
        
        it('has no hardcoded secrets in source files', () => {
          const sourceFile = '{{sourceFile}}';
          const content = fs.readFileSync(sourceFile, 'utf-8');
          
          for (const { pattern, name } of SECRET_PATTERNS) {
            const matches = content.match(pattern);
            expect(matches).toBeNull();
          }
        });
        
        it('loads secrets from environment variables', () => {
          // Config should reference process.env
          const config = require('{{configPath}}');
          const configSource = fs.readFileSync(
            require.resolve('{{configPath}}'),
            'utf-8'
          );
          
          expect(configSource).toMatch(/process\.env/);
        });
        
        it('has .env in .gitignore', () => {
          const gitignore = fs.readFileSync('.gitignore', 'utf-8');
          
          expect(gitignore).toContain('.env');
          expect(gitignore).toMatch(/\*\.pem|\.pem/);
        });
        
        it('does not commit secrets to version control', async () => {
          const { execSync } = require('child_process');
          
          // Check if any secrets are staged
          try {
            const staged = execSync('git diff --cached --name-only', { encoding: 'utf-8' });
            const stagedFiles = staged.split('\n').filter(Boolean);
            
            for (const file of stagedFiles) {
              if (file.endsWith('.env') || file.endsWith('.pem') || file.endsWith('.key')) {
                throw new Error(`Sensitive file staged: ${file}`);
              }
            }
          } catch (e) {
            // Not a git repo, skip
          }
        });
      });
    variables:
      - name: className
        type: string
        description: Name of the test class
        required: true
      - name: sourceFile
        type: string
        description: Source file to scan
        required: true
      - name: configPath
        type: string
        description: Path to config module
        required: true

examples:
  - name: hardcoded-api-key
    concept: |
      Hardcoded API keys in source code. Keys are scraped from public repos within 
      minutes using automated tools like TruffleHog. Use environment variables or 
      secret managers instead.
    vulnerableCode: |
      # VULNERABLE: API key hardcoded in source
      STRIPE_API_KEY = "sk_FAKE_example_stripe_key_12345"
      
      def charge_customer(amount):
          stripe.api_key = STRIPE_API_KEY
          return stripe.Charge.create(amount=amount)
    testCode: |
      import re
      
      def test_no_hardcoded_stripe_key():
          """Verify Stripe key is not hardcoded"""
          import inspect
          source = inspect.getsource(charge_customer)
          
          # Should not contain Stripe live/test keys
          assert not re.search(r'sk_(live|test)_[a-zA-Z0-9]{24,}', source)
    language: python
    severity: critical

  - name: aws-credentials
    concept: |
      AWS credentials hardcoded in source. AWS Access Key IDs follow a predictable 
      pattern (AKIA...) making them easy to detect. Exposed AWS keys enable account 
      takeover, resource abuse, and data exfiltration.
    vulnerableCode: |
      # VULNERABLE: AWS credentials in code
      AWS_ACCESS_KEY_ID = "AKIAIOSFODNN7EXAMPLE"
      AWS_SECRET_ACCESS_KEY = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
      
      s3 = boto3.client('s3',
          aws_access_key_id=AWS_ACCESS_KEY_ID,
          aws_secret_access_key=AWS_SECRET_ACCESS_KEY
      )
    testCode: |
      import re
      import os
      
      def test_aws_credentials_from_environment():
          """Verify AWS credentials are loaded from environment"""
          # Should use environment or IAM roles
          assert os.environ.get('AWS_ACCESS_KEY_ID') is not None or \
                 os.environ.get('AWS_PROFILE') is not None, \
              "AWS credentials should come from environment or IAM"
    language: python
    severity: critical
    cve: CVE-2019-19576

  - name: jwt-secret-hardcoded
    concept: |
      JWT signing secret hardcoded in source. If the secret is exposed, attackers 
      can forge valid tokens to impersonate any user. Use environment variables 
      and rotate secrets regularly.
    vulnerableCode: |
      // VULNERABLE: JWT secret in source code
      const JWT_SECRET = "super-secret-key-that-should-not-be-here";
      
      function signToken(payload) {
        return jwt.sign(payload, JWT_SECRET, { expiresIn: '24h' });
      }
    testCode: |
      describe('JWT Configuration', () => {
        it('loads secret from environment', () => {
          expect(process.env.JWT_SECRET).toBeDefined();
          expect(process.env.JWT_SECRET?.length).toBeGreaterThan(32);
        });
        
        it('does not have hardcoded secret in source', () => {
          const source = fs.readFileSync('auth.ts', 'utf-8');
          expect(source).not.toMatch(/JWT_SECRET\s*=\s*["']/);
        });
      });
    language: typescript
    severity: critical

createdAt: 2024-01-01
updatedAt: 2024-01-01
