id: rate-limiting
version: 1
name: Missing Rate Limiting
description: |
  Flags endpoints that may lack rate limiting for manual review. Rate limiting
  is often implemented at infrastructure level (nginx, API gateways, Cloudflare)
  rather than in application code, making static analysis unreliable.
  
  Detection confidence: LOW (<30%)
  This category flags for MANUAL REVIEW. Static analysis can detect:
  - Absence of rate-limit middleware in code
  - Login/auth endpoints without visible throttling
  
  Static analysis CANNOT detect:
  - Infrastructure-level rate limiting (nginx, AWS WAF, Cloudflare)
  - API gateway throttling
  - Load balancer configurations
  
  FUTURE: AI-assisted review agent can correlate code with infra configs.
domain: security
level: integration
priority: P1
severity: high
applicableLanguages:
  - python
  - typescript
  - javascript

cves:
  - CVE-2021-21315
  - CVE-2020-8945

references:
  - https://owasp.org/API-Security/editions/2023/en/0xa4-unrestricted-resource-consumption/
  - https://cwe.mitre.org/data/definitions/770.html
  - https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html

detectionPatterns:
  # These flag for review - infrastructure may handle rate limiting
  
  # No rate limit package detected
  - id: no-rate-limit-package
    type: regex
    language: typescript
    pattern: "(express|fastify|koa)\\s*\\(\\)"
    confidence: low
    description: |
      [REVIEW REQUIRED] Web framework initialized.
      Verify rate limiting is configured (app-level or infrastructure).
    negativePattern: "rate-limit|rateLimit|express-rate-limit|@fastify/rate-limit|koa-ratelimit"

  # Auth endpoints without visible rate limiting
  - id: login-no-limiter-ts
    type: regex
    language: typescript
    pattern: "\\.(post|put)\\s*\\([\"'`]/?(api/)?(auth/)?login|signin|authenticate[\"'`]"
    confidence: low
    description: |
      [REVIEW REQUIRED] Login endpoint detected.
      Verify rate limiting protects against brute force.
    negativePattern: "rateLimit|limiter|throttle|slowDown"

  - id: register-no-limiter-ts
    type: regex
    language: typescript
    pattern: "\\.(post)\\s*\\([\"'`]/?(api/)?(auth/)?register|signup|create-account[\"'`]"
    confidence: low
    description: |
      [REVIEW REQUIRED] Registration endpoint detected.
      Verify rate limiting prevents abuse.

  - id: password-reset-no-limiter
    type: regex
    language: typescript
    pattern: "\\.(post)\\s*\\([\"'`]/?(api/)?(auth/)?password|reset|forgot[\"'`]"
    confidence: low
    description: |
      [REVIEW REQUIRED] Password reset endpoint detected.
      Verify rate limiting prevents enumeration/abuse.

  # Python patterns
  - id: login-no-limiter-py
    type: regex
    language: python
    pattern: "@(app|router)\\.(post|put)\\s*\\([\"']/?(api/)?(auth/)?login|signin[\"']"
    confidence: low
    description: |
      [REVIEW REQUIRED] Login endpoint in Python app.
      Verify rate limiting is configured.
    negativePattern: "limiter|throttle|ratelimit|slowapi"

  - id: fastapi-no-slowapi
    type: regex
    language: python
    pattern: "from fastapi import FastAPI"
    confidence: low
    description: |
      [REVIEW REQUIRED] FastAPI app detected.
      Verify SlowAPI or similar rate limiting is configured.
    negativePattern: "slowapi|limiter|ratelimit"

  - id: django-no-throttle
    type: regex
    language: python
    pattern: "REST_FRAMEWORK\\s*=\\s*\\{"
    confidence: low
    description: |
      [REVIEW REQUIRED] Django REST Framework detected.
      Verify DEFAULT_THROTTLE_CLASSES is configured.
    negativePattern: "THROTTLE|throttle_classes"

  # API endpoints that should have limits
  - id: expensive-operation-no-limit
    type: regex
    language: typescript
    pattern: "\\.(post|put)\\s*\\([\"'`]/?(api/)?(upload|export|report|batch|bulk)[\"'`]"
    confidence: low
    description: |
      [REVIEW REQUIRED] Expensive operation endpoint detected.
      Verify rate limiting prevents resource exhaustion.

testTemplates:
  - id: pytest-rate-limit-review
    language: python
    framework: pytest
    template: |
      import pytest
      import asyncio
      import time
      
      
      class Test{{className}}RateLimiting:
          """
          Rate limiting review tests for {{moduleName}}
          
          NOTE: These tests verify application-level rate limiting.
          If rate limiting is handled at infrastructure level (nginx, API gateway),
          these tests may fail locally but pass in production.
          
          [MANUAL REVIEW] Verify one of:
          1. Application-level rate limiting is implemented
          2. Infrastructure-level rate limiting is configured
          3. CDN/WAF provides rate limiting (Cloudflare, AWS WAF)
          """
          
          RATE_LIMITED_ENDPOINTS = [
              {{#endpoints}}
              {"method": "{{method}}", "path": "{{path}}", "limit": {{limit}}, "window": "{{window}}"},
              {{/endpoints}}
          ]
          
          @pytest.mark.parametrize("endpoint", RATE_LIMITED_ENDPOINTS)
          async def test_endpoint_has_rate_limit(self, client, endpoint):
              """[REVIEW] Verify endpoint returns 429 after exceeding limit"""
              method = endpoint["method"].lower()
              path = endpoint["path"]
              limit = endpoint["limit"]
              
              responses = []
              for i in range(limit + 10):
                  response = await getattr(client, method)(path, json={})
                  responses.append(response.status_code)
              
              # Should see 429 after limit exceeded
              has_rate_limit = 429 in responses
              
              if not has_rate_limit:
                  pytest.skip(
                      f"[MANUAL REVIEW] No 429 response from {method.upper()} {path}. "
                      f"Verify rate limiting exists at infrastructure level."
                  )
          
          async def test_login_brute_force_protection(self, client):
              """[REVIEW] Verify login endpoint has brute force protection"""
              login_attempts = []
              
              for i in range(20):
                  response = await client.post("/api/auth/login", json={
                      "username": "attacker",
                      "password": f"wrong_password_{i}"
                  })
                  login_attempts.append(response.status_code)
                  
                  if response.status_code == 429:
                      break
              
              if 429 not in login_attempts:
                  pytest.skip(
                      "[MANUAL REVIEW] No rate limit on login after 20 attempts. "
                      "Verify brute force protection exists at infrastructure level."
                  )
          
          async def test_password_reset_rate_limit(self, client):
              """[REVIEW] Verify password reset is rate limited"""
              for i in range(10):
                  response = await client.post("/api/auth/password-reset", json={
                      "email": f"test{i}@example.com"
                  })
                  
                  if response.status_code == 429:
                      return  # Rate limit working
              
              pytest.skip(
                  "[MANUAL REVIEW] No rate limit on password reset. "
                  "Verify email enumeration protection exists."
              )
          
          def test_rate_limit_headers_present(self, client):
              """[REVIEW] Verify rate limit headers are returned"""
              response = client.get("/api/health")
              
              rate_limit_headers = [
                  "X-RateLimit-Limit",
                  "X-RateLimit-Remaining", 
                  "X-RateLimit-Reset",
                  "RateLimit-Limit",
                  "RateLimit-Remaining",
              ]
              
              has_headers = any(h in response.headers for h in rate_limit_headers)
              
              if not has_headers:
                  pytest.skip(
                      "[MANUAL REVIEW] No rate limit headers in response. "
                      "This is acceptable if rate limiting is at infrastructure level."
                  )
    variables:
      - name: className
        type: string
        description: Test class name
        required: true
      - name: moduleName
        type: string
        description: Module being tested
        required: true
      - name: endpoints
        type: array
        description: List of endpoints to test
        required: true

  - id: jest-rate-limit-review
    language: typescript
    framework: jest
    template: |
      /**
       * Rate Limiting Review Tests for {{moduleName}}
       * 
       * NOTE: If rate limiting is at infrastructure level (nginx, API gateway),
       * these tests may fail locally. Verify in deployment environment.
       */
      
      describe('{{className}} Rate Limiting Review', () => {
        const RATE_LIMITED_ENDPOINTS = {{endpoints}};
        
        describe.each(RATE_LIMITED_ENDPOINTS)(
          '[REVIEW] $path rate limiting',
          ({ method, path, limit }) => {
            it(`returns 429 after ${limit} requests`, async () => {
              const responses: number[] = [];
              
              for (let i = 0; i < limit + 10; i++) {
                const response = await fetch(`${BASE_URL}${path}`, { method });
                responses.push(response.status);
                
                if (response.status === 429) break;
              }
              
              if (!responses.includes(429)) {
                console.warn(
                  `[MANUAL REVIEW] No 429 from ${method} ${path}. ` +
                  `Verify infrastructure-level rate limiting.`
                );
              }
              
              expect(responses).toContain(429);
            });
          }
        );
        
        describe('brute force protection', () => {
          it('[REVIEW] login endpoint rate limited', async () => {
            const responses: number[] = [];
            
            for (let i = 0; i < 20; i++) {
              const response = await fetch(`${BASE_URL}/api/auth/login`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  username: 'attacker',
                  password: `wrong_${i}`
                })
              });
              
              responses.push(response.status);
              if (response.status === 429) break;
            }
            
            if (!responses.includes(429)) {
              console.warn('[MANUAL REVIEW] No rate limit on login endpoint');
            }
          });
        });
        
        describe('rate limit headers', () => {
          it('[REVIEW] returns rate limit headers', async () => {
            const response = await fetch(`${BASE_URL}/api/health`);
            
            const hasHeaders = 
              response.headers.has('x-ratelimit-limit') ||
              response.headers.has('ratelimit-limit') ||
              response.headers.has('retry-after');
            
            if (!hasHeaders) {
              console.warn(
                '[MANUAL REVIEW] No rate limit headers. ' +
                'Acceptable if using infrastructure-level limiting.'
              );
            }
          });
        });
      });
    variables:
      - name: className
        type: string
        description: Test class name
        required: true
      - name: moduleName
        type: string
        description: Module being tested
        required: true
      - name: endpoints
        type: array
        description: List of endpoints to test
        required: true

examples:
  - name: missing-rate-limit-login
    concept: |
      Login endpoint without rate limiting enables brute force attacks. Attackers
      can attempt thousands of password combinations. Note: Rate limiting may be 
      at infrastructure level (nginx, API gateway) rather than in application code.
    vulnerableCode: |
      // No visible rate limiting - MAY BE HANDLED BY INFRASTRUCTURE
      app.post('/api/auth/login', async (req, res) => {
        const { username, password } = req.body;
        const user = await authenticate(username, password);
        
        if (!user) {
          return res.status(401).json({ error: 'Invalid credentials' });
        }
        
        res.json({ token: generateToken(user) });
      });
    testCode: |
      describe('login rate limiting', () => {
        it('[REVIEW] prevents brute force', async () => {
          const attempts = [];
          
          for (let i = 0; i < 20; i++) {
            const response = await request(app)
              .post('/api/auth/login')
              .send({ username: 'target', password: `wrong_${i}` });
            
            attempts.push(response.status);
            if (response.status === 429) break;
          }
          
          // If no 429, verify infrastructure rate limiting exists
          expect(attempts).toContain(429);
        });
      });
    language: typescript
    severity: high

  - name: expensive-endpoint-no-limit
    concept: |
      Expensive operations (reports, exports, bulk operations) without rate limiting
      enable resource exhaustion attacks. An attacker can trigger many expensive
      operations simultaneously, causing denial of service.
    vulnerableCode: |
      @app.post("/api/reports/generate")
      async def generate_report(request: ReportRequest):
          # Expensive operation - no rate limit visible
          report = await generate_large_report(request.params)
          return report
    testCode: |
      async def test_report_generation_rate_limited(client):
          """[REVIEW] Verify expensive report endpoint is rate limited"""
          responses = []
          
          for i in range(10):
              response = await client.post("/api/reports/generate", json={})
              responses.append(response.status_code)
          
          if 429 not in responses:
              pytest.skip("[MANUAL REVIEW] No visible rate limit on /api/reports/generate")
    language: python
    severity: high

  - name: password-reset-no-limit
    concept: |
      Password reset endpoint without rate limiting enables email enumeration and
      spam. Attackers can flood valid emails with reset links or probe which emails
      exist in the system based on response timing or messages.
    vulnerableCode: |
      // No rate limiting on password reset
      app.post('/api/auth/forgot-password', async (req, res) => {
        const { email } = req.body;
        const user = await db.findUserByEmail(email);
        
        if (user) {
          await sendPasswordResetEmail(user.email);
        }
        
        // Same response to prevent enumeration (good)
        // But no rate limit (bad - allows spam/probing)
        res.json({ message: 'If email exists, reset link sent' });
      });
    testCode: |
      describe('password reset rate limiting', () => {
        it('[REVIEW] limits password reset attempts', async () => {
          const responses = [];
          
          for (let i = 0; i < 10; i++) {
            const response = await request(app)
              .post('/api/auth/forgot-password')
              .send({ email: `test${i}@example.com` });
            
            responses.push(response.status);
            if (response.status === 429) break;
          }
          
          // Should see 429 after several attempts
          expect(responses).toContain(429);
        });
      });
    language: typescript
    severity: high

createdAt: 2024-01-01
updatedAt: 2024-01-01
